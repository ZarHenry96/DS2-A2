\documentclass[11pt,twocolumn,letterpaper]{article}

%\usepackage{cvpr}
\usepackage{subfig}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[backend=biber, style=ieee]{biblatex}
\usepackage{url}
\usepackage[bookmarks=true]{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{appendix}
\usepackage{booktabs}
\bibliography{biblio}

\begin{document}
	
	%%%%%%%%% TITLE
	\title{Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications}
	
	\author{Alessandro Cacco\\
		mat. 203345\\
		{\tt\small alessandro.cacco@studenti.unitn.it}
		\and
		Andrea Ferigo\\
		mat. 207486\\
		{\tt\small andrea.ferigo@studenti.unitn.it}
		\and
		Enrico Zardini\\
		mat. 207465\\
		{\tt\small enrico.zardini@studenti.unitn.it}
	}
	\date{}
	\maketitle
	
	\section{Introduction}
	\label{sec:intro}
	This work aims at illustrating an implementation of \textit{Chord}, a scalable distributed lookup protocol described in \cite{chord}. Basically, \textit{Chord} provides a primitive, i.e. \textit{lookup}, that allows to determine the responsible of a key in an efficient way. Hence, it represents a great solution to the data location problem: each data item needs just to be associated to a key and stored in the node the key maps to. \newline 
	In practice, the nodes are logically arranged in a ring topology and each of them is responsible of the ids belonging to the interval $(predecessorId, nodeId]$ \footnote{All the arithmetic is modulo $2^m$, where $m$ is the number of bits of the identifiers.}. The key-data pairs are assigned to nodes based on the hash value of the key and consistent hashing is used in order to keep the load balanced. Moreover, each node is required to maintain information about only a few other nodes: the predecessor, some successors and the nodes contained in the finger table\footnote{The finger table is a routing table: the $i^{th}$ entry points at the responsible of the identifier $nodeId+2^{i-1}$.}. Therefore, \textit{Chord} scales well to large numbers of nodes without affecting performance. Actually, it adapts effectively also in dynamic environments with frequent joins and leaves thanks to a simple stabilization algorithm. \newline
	Starting from this, \cref{sec:implementation} will describe in detail the implementation, \cref{sec:simulator} will present the graphical simulator that has been developed to show the protocol's functioning and \cref{sec:analyses} will describe the simulations that have been performed and the results obtained. 
	
	\section{Implementation}
	\label{sec:implementation}
	This section presents the methods and the behaviour of the five classes that have been used to implement the protocol. In particular, these classes can be subdivided into three groups:
	\begin{itemize}
		\item the control class (\texttt{TopologyBuilder}) that instantiates the nodes, initialises the ring, manages joins/leaves and initiates the lookups;
		\item the class (\texttt{Node}) that defines the behaviour of the agents in the simulation, i.e. the nodes;
		\item the support classes (\texttt{FingerTable}, \texttt{Lookup} and \texttt{Utils}).
	\end{itemize}
	
	\section{Simulator}
	\label{sec:simulator}
	
	\section{Analyses and Results}
	\label{sec:analyses}
	
	\printbibliography
\end{document}















































