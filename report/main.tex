\documentclass[11pt,twocolumn,letterpaper]{article}

%\usepackage{cvpr}
\usepackage{subfig}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[backend=biber, style=ieee]{biblatex}
\usepackage{url}
\usepackage[bookmarks=true]{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{appendix}
\usepackage{booktabs}
\usepackage{multirow}
\bibliography{biblio}

\begin{document}
	
	%%%%%%%%% TITLE
	\title{Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications}
	
	\author{Alessandro Cacco\\
		mat. 203345\\
		{\tt\small alessandro.cacco@studenti.unitn.it}
		\and
		Andrea Ferigo\\
		mat. 207486\\
		{\tt\small andrea.ferigo@studenti.unitn.it}
		\and
		Enrico Zardini\\
		mat. 207465\\
		{\tt\small enrico.zardini@studenti.unitn.it}
	}
	\date{}
	\maketitle
	
	\section{Introduction}
	\label{sec:intro}
	This work aims at illustrating an implementation of Chord, a scalable distributed lookup protocol described in \cite{chord}. Basically, Chord provides a primitive, i.e. \textit{lookup}, that allows to determine the responsible for a key in an efficient way. Hence, it represents a great solution to the data location problem: each data item needs just to be associated with a key and stored in the node to which the key is mapped. \newline 
	In practice, the nodes are logically arranged in a ring topology and each of them is responsible for the ids belonging to the interval $(predecessorId, nodeId]$ \footnote{The ids are integers in $[0,2^m)$, where $m$ is the number of bits of the identifiers. All the arithmetic is modulo $2^m$.}. The key-data pairs are assigned to the nodes depending on the hash value of the key and consistent hashing is used in order to keep the load balanced. Moreover, each node is required to maintain information about only a few other nodes: the predecessor, some successors and the elements of the finger table\footnote{The finger table is a routing table: the $i^{th}$ entry points at the responsible for the identifier $nodeId+2^{i-1}$, with $1\leq i \leq$ m.\label{foot:ftable}}. Therefore, Chord scales well to large numbers of nodes without affecting performance. Actually, it adapts effectively also in dynamic environments with frequent joins and leaves thanks to a simple stabilization algorithm. \newline
	Finally, it is worth mentioning that the iterative version of Chord has been implemented. Hence, a node resolving a lookup initiates all the communications needed to reach the target. \newline
	Starting from this, \cref{sec:implementation} will describe in detail the implementation, \cref{sec:simulator} will present the graphical simulator that has been developed to show the protocol's functioning and \cref{sec:analyses} will describe the simulations that have been performed and the results obtained. 
	
	\section{Implementation}
	\label{sec:implementation}
	This section presents the methods and the behaviour of the five classes that have been used to implement the protocol. In particular, these classes can be subdivided into three groups:
	\begin{itemize}
		\item the control class (\texttt{TopologyBuilder}) that instantiates the nodes, initialises the ring, manages joins/leaves and initiates the lookups;
		\item the class (\texttt{Node}) that defines the behaviour of the agents in the simulation, i.e. the nodes;
		\item the support classes (\texttt{FingerTable}, \texttt{Lookup} and \texttt{Utils}).
	\end{itemize}
	Before going into details, it is worth mentioning that the correspondence between simulation ticks and seconds has been assumed in both implementation and simulations. 

	\subsection{TopologyBuilder}
	\label{subsec:topbuilder}
	As indicated in the previous section the \texttt{TopologyBuilder} has different duties, which can be divided into two macro-phase: the initialization and the scheduling. During the first phase the node and the data are initialized, instead in the second are scheduled both the join/leave process for nodes and the lookups.
	 
	\subsubsection{Initialization}
	\label{subsubsec:top-init}
	First of all the \texttt{TopologyBuilder} initialise the ring with a number of nodes indicated by the parameter \textit{init\_num\_nodes}, the nodes can be initialise in two different ways\footnote{It is possible change from a mode to the other using the parameter \textit{one\_at\_time\_init}.}. In the first mode, each node is inserted one at time using as successor a random node already present in the network and leaving between two insertion a time indicated by parameter \textit{inseriton\_delay}, which is greater than the maximum time needed for a stabilization, i.e. there is always a stabilization round between two insertions. Note that, the first node inserted does not make a \textit(join()) but call the method \textit{create()}, as highlight in \cref{subsubsec:init}. The other procedure proceed in a different way, indeed each node is inserted with his correct successor without delay between the insertion and no \textit{create()} method is called, this in order to simulate a ring which as already reached the initial structure.
	The second thing that the node have to initialise are the data, after a stabilisation round from the last join the \texttt{TopologyBuilder} create the data according to 3 parameter: \textit{data\_size}, \textit{key\_size} and \textit{total\_number\_data} which indicates the size of the random string that symbolize the data, the size of the sub-string used as key, and the total number of data present in the ring, respectively\footnote{Note that the size indicates the number of characters used to create the string. Moreover is important to remember that there can not be more than $2^m -1$ data.}. After that all the data are generated, the \texttt{TopologyBuilder} assign each key to first node active which has a id greater than the key\footnote{Clearly all the keys greater to the last active node, are given to the smallest node in order to respect the modular structure of the ring.}.
	
	\subsubsection{Scheduling}
	\label{subsubsec:top-scheduling}
	As introduced the function which are scheduled by the \texttt{TopologyBuilder} are of two different type, the first manage the leave/join process, the other manages the creations of the lookup.\\
	The first leaving is scheduled after the last node inserted have done a stabilisation plus a \textit{leave\_interval} and is repeated each \textit{leave\_interval}. During a \textit{leaving} a set of active nodes\footnote{The number of nodes leaving the ring can be setted trough two parameters: \textit{min\_number\_leaving} and \textit{leaving\_amplitude}.} is selected and is scheduled their exit at distance of one tick from each other, this is done, in order to have the time to advice the neighbours and transfer the data. After that the last node left the ring, a number of tick equals to \textit{join\_interval} ticks are waited before start the joining procedure. During the \textit{joining} a set of nodes\footnote{As for the leaving the number of nodes entering can be decided trough two parameters.} enter in the ring, in contrast to the initialization phase, there is any delay between two insertions, so in order to maintain the consistency each joining node cannot choose a node which has just joined as his successor.
	Is important to note that this is not the only way in which a node can leave, indeed, as described in \cref{subsec:leaving}, if a node is forced to leaving it is removed from the active nodes, and a node in more is scheduled to join at the next join procedure.\\
	As regards to the lookups the procedure is similar to what previously described, \textit{lookup\_interval} ticks after the data generation, the \texttt{TopologyBuilder} schedules the creation of \textit{number\_lookup} query each \textit{lookup\_interval}\footnote{In case that the number of nodes initialized and not crashed is lesser than the \textit{number\_lookup} all the alive nodes create a query, as a node can do only a lookup at once.}. There can be two different behaviour used to create the lookups: one where each query search the same key and one where each query search for a different key.
	
	
	\subsection{Node}
	\label{subsec:node}
	The \texttt{Node} class, which defines the behaviour of the agents in the simulations, consists of several methods that can be grouped into six categories:
	\vspace{-2pt}
	\begin{itemize}
		\itemsep0pt
		\item initialization;
		\item lookup;
		\item stabilization;
		\item data management;
		\item crash and recovery;
		\item leaving.
	\end{itemize}
	\vspace{-1pt}
	Each of them will be examined in a specific Section. As regards the main fields, every node maintains: a finger table (the implementation will be presented in \cref{subsubsec:finger-table}), a list of successors, a reference to the predecessor and a key-value map for data. \newline
	Basically, the finger table - as a routing table - allows to perform efficient and scalable lookups. In fact, the finger table is not needed for correctness\footnote{It is sufficient that every node knows its successor to achieve correctness.} but avoids lookups characterised by a number of messages linear in the number of nodes. \newline
	Instead, the list of successors improves the robustness to failures and departures w.r.t. just a reference to the immediate successor. In fact, all successors would have to fail simultaneously in order to destroy the ring. It is worth mentioning that the first elements of the finger table and the successor list coincide. \newline
	As regards the reference to the predecessor, it is exploited by the stabilization algorithm to maintain the consistency of the successors and is used to transfer part of the data to the new responsible in presence of a join.
	
	\subsubsection{Initialization}
	\label{subsubsec:init}
	As described in \cref{subsec:topbuilder}, two ring initialization modalities are supported: the insertion of one node at a time until the desired size has been reached; the creation of a ring of the desired size where each node knows the immediate successor. \newline
	The former is supported by the \textit{create()} and \textit{join()} methods: \textit{create()} is called on the first node in order to build a new Chord ring, whereas \textit{join()} performs all the operations required to join an existing ring. Hence, \textit{join()} is used also after the initial phase of the simulation to insert new nodes in the ring. \newline
	Instead, the latter is supported by the \textit{initSuccessor()} method, which initialises the successor list using the node provided. \newline
	As regards joining an existing ring, it implies asking a node already contained in the ring for the successor of the current node. This is done through the \textit{find\_successor\_step()} method, which is presented in the following Section.
	
	\subsubsection{Lookup}
	\label{subsubsec:lookup}
	As introduced in \cref{sec:intro}, the lookups are performed in an iterative way. Hence, the node on which the \textit{lookup()} method is called initiates all the communications needed to reach the responsible for the given key. \newline
	Basically, the node first checks if its successor is the responsible for the key of interest: if it is, the lookup is finished; otherwise it asks the closest preceding node (w.r.t. the given key) among the ones contained in the finger table and in the successor list. Since the iterative version has been implemented, if the contacted node's successor is not the responsible, the contacted node provides the lookup initiator with a reference to the closest preceding node among the ones it knows. The procedure is repeated until the responsible is found. \newline
	Since the same steps are performed during the stabilization, the \textit{lookup()} method just calls another function, i.e. \textit{find\_successor()}. In practice, \textit{find\_successor()} does the first check, whereas the \textit{find\_successor\_step()} method implements the iterative step. As regards the communications between nodes, they are performed through the methods \textit{processSuccRequest()} and \textit{processSuccResponse()} using an exponentially distributed packet delay with mean of 50 milliseconds (0.05 ticks) as in \cite{chord}. \newline
	Actually, the lookup initiator may not receive an answer due to a failure or an out-of-date reference (the target node has left the ring). In that case, after 500 milliseconds (0.5 ticks) it contacts the node from which it has learnt about that node in order to obtain another reference (\textit{getPrevSuccessor()} method). If that node does not reply either, the lookup initiator iterates the procedure.
	
	\subsubsection{Stabilization}
	\label{subsubsec:stabilization}
	The stabilization protocol is run periodically to ensure that the various pointers (finger table, successors, predecessor) are up-to-date. The main method is \textit{stabilization()}, which starts the various operations. \newline
	First of all, the node contacts sequentially its successors until it finds one alive (this is done in \textit{stabilization()}). At that point, if the predecessor of the replying node belongs to the interval $(nodeId,successorId)$ the current node updates its immediate successor (\textit{stabilization\_step()} method) \footnote{This may happen in case a new node has recently joined the ring.}. The next step consists in asking the immediate successor for its successor list, which is used to update the list of the current node. As regards the communication, it is managed through the methods \textit{processStabRequest()} and \textit{processStabResponse()}. In particular, the former method also verifies if the predecessor of the contacted node needs to be changed  (\textit{notifiedPredecessor()} method). In that case, the contacted node transfers the necessary data -if any- to the new predecessor and notifies the old predecessor that its successor should be changed (\textit{setNewSuccessor()} method) accelerating the integration of a new node in the ring. \newline
	Once the response has been processed, the node moves on to the stabilization of the other pointers. This is done in the \textit{fix\_data\_structures()} method: basically, the node stabilizes alternatively one entry of the finger table (\textit{fix\_fingers()} method) and one entry of the successor list (\textit{fix\_successors()} method) in addition to the predecessor. As regards the finger table, the node calls the \textit{find\_successor()} method in order to find the responsible for the id the entry points to. Instead, as for the successor list, the node calls the same method on the id of the last stabilized successor plus one. Once the responsible has been found, the corresponding data structure is updated by the method \textit{setResult()}. In particular, since the first entry of the two data structures represent the immediate successor, they are never stabilized during this phase (it has already been done in the previous one). Finally, the node checks if the predecessor is still alive: if it is not, the pointer is set to \texttt{null}, which allows the node to accept a new predecessor in the next stabilization.
	
	\subsubsection{Data management}
	\label{subsubsec:data-management}
	The data management category includes two methods: \textit{transferDataUpToKey()} and \textit{newData()}. \newline
	Basically, the former extracts the data with a hash value of the key up to a target value from the data owned by the current node, whereas the latter performs the acquisition of new data. In practice, these methods are exploited to transfer data: to the new predecessor; to the successor before leaving the ring (this operation is managed by the \texttt{TopologyBuilder}). 
	
	\subsubsection{Crash and recovery}
	\label{subsubsec:crash-n-recovery}
	Nodes failures are simulated as follows: each node periodically crashes with a certain probability (\textit{nodeCrash()} method) and schedules the recovery after a specific interval (\textit{recovery()} method). While failed the node does not process any request or response. Instead, once it is up again, it performs immediately a stabilization using the references it had before crashing.
	
	\subsubsection{Leaving}
	\label{subsubsec:leaving}
	As described in \cref{subsubsec:top-scheduling}, nodes leavings are decided and scheduled by the \texttt{TopologyBuilder}. However, all the operations that a node has to perform before leaving the ring are implemented in the \textit{leave()} method
	of the \texttt{Node} class. \newline
	Basically, the node contacts first the immediate successor notifying it of the departure and providing it with the new predecessor -if it is not \texttt{null}- and the data the current node was holding (\textit{setPredecessor()} and \textit{newData()} methods). Then, it contacts the predecessor providing it with its immediate and last successor, which are used to update the successor list of the predecessor node (\textit{setLastSuccessor()} method). At that point, the node can safely leave the ring and clear all its data structures (\textit{clearAll()} mehtod). \newline
	Actually, a node may also be forced to leave the ring. In fact, if during a stabilization or a lookup operation it realizes that all its successors are failed or have left the ring, it is forced to leave the ring. This is managed by the \textit{forcedLeaving()} method, which notifies the predecessor of the departure (\textit{successorLeaving()} method), clears all the data structures and communicates the leaving to the \texttt{TopologyBuilder} that will insert an additional node in the next join round.
		
	\subsection{Support classes}
	\label{subsec:support-classes}
	This section briefly describes the structure of the three classes that support the operations of \texttt{TopologyBuilder} and \texttt{Node}, i.e.: \texttt{FingerTable}, \texttt{Lookup} and \texttt{Utils}.
	
	\subsubsection{FingerTable}
	\label{subsubsec:finger-table}
	The \texttt{FingerTable} class defines the structure of the finger table, which is nothing more than a routing table, as described in \cref{foot:ftable}. In practice, the finger table has been implemented as an hash-map: the key corresponds to the index of the routing table, whereas the value is the reference to the pointed node. Moreover, the \texttt{FingerTable} class provides all the necessary methods to interact with the finger table, such as \textit{getEntry()}, \textit{setEntry()}, \textit{getKeys()}, \textit{removeEntry()} etc.
	
	\subsubsection{Lookup}
	\label{subsubsec:lookup-class}
	The \texttt{Lookup} class provides a useful structure for keeping track of the information related to a specific lookup. \newline
	In particular, when the \texttt{TopologyBuilder} initiates a lookup, it creates a new instance of the \texttt{Lookup} class providing information such as the hash value of the target key, the id of the node performing the lookup, the starting tick and the correct result (id). \newline
	Once the lookup has been finished, the lookup initiator calls the \textit{setResult()} method on the corresponding \texttt{Lookup} instance providing the result information, i.e. the reference to the node responsible for the target key, the path length, the number of timeouts and the number of nodes contacted. At that point, a check to verify if the right node has been found and it has effectively the key is performed.
	
	\subsubsection{Utils}
	\label{subsubsec:utils}
	The \texttt{Utils} class provides three static utility methods: \textit{getHash()}, \textit{getNextDelay()} and \textit{belongsToInterval()}. \newline
	The first one computes the hash value of the key provided (SHA-1 is used). The second one returns a random delay taken from an exponential distribution with mean equal to the one supplied. The last one verifies if the value provided belongs to the interval defined by the endpoints supplied in modular arithmetic.
	
	\section{Simulator}
	\label{sec:simulator}
	
	\section{Analyses and Results}
	\label{sec:analyses}
	\begin{table}[!ht]
		\caption{Default protocol parameters for the executed experimental runs.}
		\label{tab:default_params}
		\centering
		\begin{tabular}{lc}
			\hline
			\textbf{Parameter} & \textbf{Value} \\
			\hline
			Crash probability & 0.05\\
			\hline
			Crash recovery interval & 25\\
			\hline
			Crash scheduling interval & 60\\
			\hline
			Key size & 5 \\
			\hline
			Number of keys & 1500\\
			\hline
			Value size & 10\\
			\hline
			Hash size & 12\\
			\hline
			Initial number of nodes & 1000\\
			\hline
			Successors list & 20\\
			\hline
			Join tick period & 20\\
			\hline
			Join amplitude & 0\\
			\hline
			Join min number of nodes & 10\\
			\hline
			Leave tick period & 50\\
			\hline
			Leave amplitude & 0\\
			\hline
			Leave min number of nodes & 10\\
			\hline
			Lookup period & 35\\
			\hline
			Lookups per batch & 500\\
			\hline
			Single key lookup & no\\
			\hline
			Stabilization amplitude & 1\\
			\hline
			Stabilization period & 15\\
			\hline
		\end{tabular}
	\end{table}

	This section presents the simulation runs that have been executed to test the protocol strength and performance, with their respective analyses and results explanations. The parameters involved in our simulations are explained in \cref{tab:default_params}, with the corresponding default parameters. The performed runs are designed with variations on the default parameters so four analyses are possible, namely:
	\begin{itemize}
		\item Crash probability analysis (\cref{subsec:crash_analysis}), in order to understand the impact of having a higher number of nodes crashing during the protocol, causing errors in the other nodes data structures;
		\item Network size analysis (\cref{subsec:netsize_analysis}), with proportioned lookup batch sizes, allows both for scaling testing and for lookup load stress-testing;
		\item Key number analysis (\cref{subsec:keyno_analysis}), testing the scaling performance of the protocol wrt the number of keys in the system
	\end{itemize}
	
	\subsection{Impact of crashing nodes}
	\label{subsec:crash_analysis}
	
	\begin{table}[h!]
		\caption{Variations of the default parameters for the node crashing impact analysis. Note that \texttt{R01} is the default run with no variations}
		\label{tab:crash_runs}
		\centering
		\begin{tabular}{cc}
			\hline
			\textbf{Run} & \textbf{Crash probability}\\
			\hline
			\texttt{R01} & $0.05$\\
			\hline
			\texttt{R02} & $0.1$\\
			\hline
			\texttt{R03} & $0.2$\\
			\hline
			\texttt{R04} & $0.3$\\
			\hline
		\end{tabular}
	\end{table}		

	\subsection{Protocol network size scaling}
	\label{subsec:netsize_analysis}
	
	\begin{table}[h!]
		\caption{Variations of the default parameters for the scaling analysis runs. \texttt{R01} is omitted being the default run with no variations.}
		\label{tab:netsize_runs}
		\centering
		\begin{tabular}{lc}
			\hline
		    \multicolumn{2}{c}{\texttt{R05}}\\
			\hline
			Number of keys & 30\\
			\hline
			Hash size & 5\\
			\hline
			Initial number of nodes & 25\\
			\hline
			Successors list & 8\\
			\hline
			Join min number of nodes & 2\\
			\hline
			Leave min number of nodes & 2\\
			\hline
			Lookups per batch & 10\\
			\hline
			\hline
		    
		    \multicolumn{2}{c}{\texttt{R06}}\\
			\hline
			Number of keys & 60\\
			\hline
			Hash size & 6\\
			\hline
			Initial number of nodes & 50\\
			\hline
			Successors list & 10\\
			\hline
			Join min number of nodes & 3\\
			\hline
			Leave min number of nodes & 3\\
			\hline
			Lookups per batch & 25\\
			\hline
			\hline

			\multicolumn{2}{c}{\texttt{R07}}\\
			\hline
			Number of keys & 1000\\
			\hline
			Hash size & 10\\
			\hline
			Initial number of nodes & 500\\
			\hline
			Successors list & 15\\
			\hline
			Join min number of nodes & 5\\
			\hline
			Leave min number of nodes & 5\\
			\hline
			Lookups per batch & 250\\
			\hline
			\hline
			
			\multicolumn{2}{c}{\texttt{R01}}\\
			\hline
			\multicolumn{2}{c}{\dots}\\
			\hline
		\end{tabular}
	\end{table}		
	
	\subsection{Performance and quantity of keys}
	\label{subsec:keyno_analysis}

	\begin{table}[h!]
		\caption{Variations of \texttt{SC} runs on the default parameters.}
		\label{tab:keyno_runs}
		\centering
		\begin{tabular}{cc}
			\hline
			\textbf{Run} & \textbf{Number of keys}\\
			\hline
			\texttt{R01} & $1000$\\
			\hline
			\texttt{R02} & $2000$\\
			\hline
			\texttt{R03} & $3000$\\
			\hline
			\texttt{R03} & $4000$\\
			\hline
		\end{tabular}
	\end{table}		

	\printbibliography
\end{document}















































