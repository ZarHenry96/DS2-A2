\documentclass[11pt,twocolumn,letterpaper]{article}

%\usepackage{cvpr}
\usepackage{subfig}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{amssymb}
\usepackage[british]{babel}
\usepackage[backend=biber, style=ieee]{biblatex}
\usepackage{url}
\usepackage[bookmarks=true]{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{appendix}
\usepackage{booktabs}
\bibliography{biblio}

\begin{document}
	
	%%%%%%%%% TITLE
	\title{Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications}
	
	\author{Alessandro Cacco\\
		mat. 203345\\
		{\tt\small alessandro.cacco@studenti.unitn.it}
		\and
		Andrea Ferigo\\
		mat. 207486\\
		{\tt\small andrea.ferigo@studenti.unitn.it}
		\and
		Enrico Zardini\\
		mat. 207465\\
		{\tt\small enrico.zardini@studenti.unitn.it}
	}
	\date{}
	\maketitle
	
	\section{Introduction}
	\label{sec:intro}
	This work aims at illustrating an implementation of Chord, a scalable distributed lookup protocol described in \cite{chord}. Basically, Chord provides a primitive, i.e. \textit{lookup}, that allows to determine the responsible for a key in an efficient way. Hence, it represents a great solution to the data location problem: each data item needs just to be associated with a key and stored in the node to which the key is mapped. \newline 
	In practice, the nodes are logically arranged in a ring topology and each of them is responsible for the ids belonging to the interval $(predecessorId, nodeId]$ \footnote{The ids are integers in $[0,2^m)$, where $m$ is the number of bits of the identifiers. All the arithmetic is modulo $2^m$.}. The key-data pairs are assigned to the nodes depending on the hash value of the key and consistent hashing is used in order to keep the load balanced. Moreover, each node is required to maintain information about only a few other nodes: the predecessor, some successors and the elements of the finger table\footnote{The finger table is a routing table: the $i^{th}$ entry points at the responsible for the identifier $nodeId+2^{i-1}$, with $1\leq i \leq$ m.}. Therefore, Chord scales well to large numbers of nodes without affecting performance. Actually, it adapts effectively also in dynamic environments with frequent joins and leaves thanks to a simple stabilization algorithm. \newline
	Finally, it is worth mentioning that the iterative version of Chord has been implemented. Hence, a node resolving a lookup initiates all the communications needed to reach the target. \newline
	Starting from this, \cref{sec:implementation} will describe in detail the implementation, \cref{sec:simulator} will present the graphical simulator that has been developed to show the protocol's functioning and \cref{sec:analyses} will describe the simulations that have been performed and the results obtained. 
	
	\section{Implementation}
	\label{sec:implementation}
	This section presents the methods and the behaviour of the five classes that have been used to implement the protocol. In particular, these classes can be subdivided into three groups:
	\begin{itemize}
		\item the control class (\texttt{TopologyBuilder}) that instantiates the nodes, initialises the ring, manages joins/leaves and initiates the lookups;
		\item the class (\texttt{Node}) that defines the behaviour of the agents in the simulation, i.e. the nodes;
		\item the support classes (\texttt{FingerTable}, \texttt{Lookup} and \texttt{Utils}).
	\end{itemize}
	Before going into details, it is worth mentioning that the correspondence between simulation ticks and seconds has been assumed in both implementation and simulations. 

	\subsection{TopologyBuilder}
	\label{subsec:topbuilder}
	As indicated in the previous section the \texttt{TopologyBuilder} has two main duty, the initialization of the ring and the data and the scheduling of joins/leaves and of the lookups. 
	\subsubsection{Initialization}
	First of all the \texttt{TopologyBuilder} initialise a ring with a number of nodes indicated by the parameter \textit(init\_num\_nodes), the nodes can be initialise in two different ways\footnote{It is possible change from a mode to the other using the parameter \textit{one\_at\_time\_init}.}. In the first case, each node is inserted one at time using as successor a random node already present in the network and leaving between two insertion a time indicated by parameter \textit{inseriton\_delay}, which is greater than the maximum time needed for a stabilization, i.e. there is always a stabilization round between two insertions, note that the first node inserted does not make a \textit(join()) but call the method \textit{create()}, as highlight in \cref{subsubsec:init}. The other procedure proceed in a different way, indeed each node is inserted with his correct successor without delay between the insertion and no \textit{create()} method is called, this in order to simulate a ring which as already reach the initial structure.
	The second thing that the node have to initialise are the data, after a stabilisation round from the last join the \texttt{TopologyBuilder} create the data according to 3 parameter: \textit{data\_size}, \textit{key\_size} and \textit{total\_number\_data} which indicates the size of the random string that symbolize the data, the size of the sub-string used as key, and the total number of data present in the ring\footnote{Note that the size indicates the number of characters used to create the string. Moreover is important to remember that there can not be more than $2^m -1$ data.}. After have generated all the data, the \texttt{TopologyBuilder} assign each key to first node active which has a id greater than the key\footnote{Clearly all the keys greater to the last active node, are given to the smallest node in order to respect the modular structure of the ring.}.
	\subsubsection{Scheduling}
	The function which are scheduled by the \texttt{TopologyBuilder} are of two different type, the first manage the leave/join process, the other manages the creations of the lookup.\\
	The first leave is scheduled after the last node inserted have done a stabilisation plus a \textit{leave\_interval} and is repeated each \textit{leave\_interval}. During a leaving a set of active nodes is selected and is scheduled their leaving at distance of one tick from each other, in order to have the time to advice the neighbours and transfer the data. After that the last node left the ring a number of tick equals to \textit{join\_interval} ticks are waited before start the joining procedure, where a set of nodes enter in the ring, in contrast to the initialization phase, there is any delay between two insertions, so in order to maintain the consistency each joining node cannot choose a node which is just joined as his successor.
	Is important to note that this is not the only way in which a node can leave, as described in \cref{subsec:leavingRide}, indeed if a node is forced to leave it is removed from the active nodes, and a node in more is scheduled to join at the next join procedure.\\
	As regards to the lookups the procedure is similar, \textit{lookup\_interval} ticks after the data generation, the \texttt{TopologyBuilder} schedules the creation of \textit{number\_lookup} query each \textit{lookup\_interval}\footnote{In case that the number of nodes initialized and not crashed is lesser than the \textit{number\_lookup} all the alive nodes create a query.}. There can be two different behaviour used to create the lookups: one where each query search the same key and one where each query search for a different key.
	
	
	\subsection{Node}
	\label{subsec:node}
	The \texttt{Node} class, which defines the behaviour of the agents in the simulations, consists of several methods that can be grouped into six categories:
	\vspace{-2pt}
	\begin{itemize}
		\itemsep0pt
		\item initialization;
		\item lookup;
		\item stabilization;
		\item data management;
		\item crash and recovery;
		\item leave.
	\end{itemize}
	\vspace{-1pt}
	Each of them will be examined in a specific Section. As regards the main fields, every node maintains: a finger table (the implementation will be presented in \cref{subsubsec:finger-table}), a list of successors, a reference to the predecessor and a key-value map for data. \newline
	Basically, the finger table - as a routing table - allows to perform efficient and scalable lookups. In fact, the finger table is not needed for correctness\footnote{It is sufficient that every node knows its successor to achieve correctness.} but avoids lookups characterised by a number of messages linear in the number of nodes. \newline
	Instead, the list of successors improves the robustness to failures and departures w.r.t. just a reference to the immediate successor. In fact, all successors would have to fail simultaneously in order to destroy the ring. It is worth mentioning that the first elements of the finger table and the successor list coincide. \newline
	As regards the reference to the predecessor, it is exploited by the stabilization algorithm to maintain the consistency of the successors and is used to transfer part of the data to the new responsible in presence of a join.
	
	\subsubsection{Initialization}
	\label{subsubsec:init}
	As described in \cref{subsec:topbuilder}, two ring initialization modalities are supported: the insertion of one node at a time until the desired size has been reached; the creation of a ring of the desired size where each node knows the immediate successor. \newline
	The former is supported by the \textit{create()} and \textit{join()} methods: \textit{create()} is called on the first node in order to build a new Chord ring, whereas \textit{join()} performs all the operations required to join an existing ring. Hence, \textit{join()} is used also after the initial phase of the simulation to insert new nodes in the ring. \newline
	Instead, the latter is supported by the \textit{initSuccessor()} method, which initialises the successor list using the node provided. \newline
	As regards joining an existing ring, it implies asking a node already contained in the ring for the successor of the current node. This is done through the \textit{find\_successor\_step()} method, which is presented in the following Section.
	
	\subsubsection{Lookup}
	\label{subsubsec:lookup}
	As introduced in \cref{sec:intro}, the lookups are performed in an iterative way. Hence, the node on which the \textit{lookup()} method is called initiates all the communications needed to reach the responsible for the given key. \newline
	Basically, the node first checks if its successor is the responsible for the key of interest: if it is, the lookup is finished; otherwise it asks the closest preceding node (w.r.t. the given key) among the ones contained in the finger table and in the successor list. Since the iterative version has been implemented, if the contacted node's successor is not the responsible, the contacted node provides the lookup initiator with a reference to the closest preceding node among the ones it knows. The procedure is repeated until the responsible is found. \newline
	Since the same steps are performed during the stabilization, the \textit{lookup()} method just calls another function, i.e. \textit{find\_successor()}. In practice, \textit{find\_successor()} does the first check, whereas the \textit{find\_successor\_step()} method implements the iterative step. As regards the communications between nodes, they are performed through the methods \textit{processSuccRequest()} and \textit{processSuccResponse()} using an exponentially distributed packet delay with mean of 50 milliseconds (0.05 ticks) as in \cite{chord}. \newline
	Actually, the lookup initiator may not receive an answer due to a failure or an out-of-date reference (the target node has left the ring). In that case, after 500 milliseconds (0.5 ticks) it contacts the node from which it has learnt about that node in order to obtain another reference (\textit{getPrevSuccessor()} method). If that node does not reply either, the lookup initiator iterates the procedure.
	
	\subsubsection{Stabilization}
	\label{subsubsec:stabilization}
	The stabilization protocol is run periodically to ensure that the various pointers (finger table, successors, predecessor) are up-to-date. The main method is \textit{stabilization()}, which starts the various operations. \newline
	First of all, the node contacts sequentially its successors until it finds one alive (this is done in \textit{stabilization()}). At that point, if the predecessor of the replying node belongs to the interval $(nodeId,successorId)$ the current node updates its immediate successor (\textit{stabilization\_step()} method) \footnote{This may happen in case a new node has recently joined the ring.}. The next step consists in asking the immediate successor for its successor list, which is used to update the list of the current node. As regards the communication, it is managed through the methods \textit{processStabRequest()} and \textit{processStabResponse()}. In particular, the former method also verifies if the predecessor of the contacted node needs to be changed  (\textit{notifiedPredecessor()} method). In that case, the contacted node transfers the necessary data -if any- to the new predecessor and notifies the old predecessor that its successor should be changed (\textit{setNewSuccessor()} method) accelerating the integration of a new node in the ring. \newline
	Once the response has been processed, the node moves on to the stabilization of the other pointers. This is done in the \textit{fix\_data\_structures()} method: basically, the node stabilizes alternatively one entry of the finger table (\textit{fix\_fingers()} method) and one entry of the successor list (\textit{fix\_successors()} method) in addition to the predecessor. As regards the finger table, the node calls the \textit{find\_successor()} method in order to find the responsible for the id the entry points to. Instead, as for the successor list, the node calls the same method on the id of the last stabilized successor plus one. Once the responsible has been found, the corresponding data structure is updated by the method \textit{setResult()}. In particular, since the first entry of the two data structures represent the immediate successor, they are never stabilized during this phase (it has already been done in the previous one). Finally, the node checks if the predecessor is still alive: if it is not, the pointer is set to \texttt{null}, which allows the node to accept a new predecessor in the next stabilization.
	
	\subsubsection{Data management}
	\label{subsubsec:data-management}
	The data management category includes two methods: \textit{transferDataUpToKey()} and \textit{newData()}. \newline
	Basically, the former extracts the data with a hash value of the key up to a target value from the data owned by the current node, whereas the latter performs the acquisition of new data. In practice, these methods are exploited to transfer data: to the new predecessor; to the successor before leaving the ring (this operation is managed by the \texttt{TopologyBuilder}). 
	
	\subsubsection{Crash and recovery}
	\label{subsubsec:crash-n-recovery}
	Nodes failures are simulated as follows: each node periodically crashes with a certain probability (\textit{nodeCrash()} method) and schedules the recovery after a certain interval (\textit{recovery()} method). While failed the node does not process any request or response. Instead, once it is up again, it performs immediately a stabilization using the references it had before crashing.
	
	\subsubsection{Leave}
	\label{subsubsec:leave}	
		
	\subsection{Support classes}
	\label{subsec:support-classes}
	
	\subsubsection{Finger Table}
	\label{subsubsec:finger-table}
	
	\subsubsection{Lookup}
	\label{subsubsec:lookup-class}
	
	\subsubsection{Utils}
	\label{subsubsec:utils}
	
	\section{Simulator}
	\label{sec:simulator}
	
	\section{Analyses and Results}
	\label{sec:analyses}
	
	\printbibliography
\end{document}















































